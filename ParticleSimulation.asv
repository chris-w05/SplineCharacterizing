%% ParticleOnBezier_AnimG.m
% Simulate particle constrained to Bézier curve, animate, track g-forces

clear; clc; close all;

% === Control points ===
CP = [0 0 0;
      -1 0 -1;
      -2 -2 -2;
      -4 -1 -1];

% === Physics parameters ===
m   = 1.0;     % kg
g   = 9.81;    % m/s^2
mu  = 0.05;    % kinetic friction
rho = 1.225;   % kg/m^3
Cd  = 1;     % drag coefficient
A   = 0.01;    % m^2

% === Time stepping ===
dt   = 1e-3;
tmax = 30;

% === Initial conditions ===
u = 0;  v = 0;  t = 0;

% Storage
maxSteps = ceil(tmax/dt);
pos_hist = zeros(maxSteps,3);
v_hist   = zeros(maxSteps,1);
aT_hist  = zeros(maxSteps,1); % tangential accel
aN_hist  = zeros(maxSteps,1); % normal accel
g_hist   = zeros(maxSteps,1);
t_hist   = zeros(maxSteps,1);
KE_hist  = zeros(maxSteps,1);
PE_hist  = zeros(maxSteps,1);

step = 1;
while t < tmax && u < 1
    % Evaluate curve + derivatives
    r   = Bezier(u,CP);
    rp  = BezierDerivative(u,CP);
    rpp = BezierSecondDerivative(u,CP);
    speed_rp = norm(rp);
    tangent  = rp / speed_rp;

    % Forces along tangent
    Fg_t = dot([0 0 -m*g], tangent);
    cosAlpha = sqrt(max(0,1 - tangent(3)^2));
    Ff = -mu*m*g*cosAlpha*sign(v);
    Fd = -0.5*rho*Cd*A*v*abs(v);
    F_net = Fg_t + Ff + Fd;

    % Tangential accel
    aT = F_net/m;

    % Integrate v (semi-implicit Euler)
    v = v + aT*dt; %if v < 0, v = 0; end

    % Update u
    du = (v*dt)/speed_rp;
    u  = min(1,u+du);

    % Normal accel from curvature
    crossProd = cross(rp,rpp);
    kappa = norm(crossProd)/(speed_rp^3);  % curvature
    aN = v^2*kappa;

    % Total g-force
    gforce = sqrt(aT^2 + aN^2)/g;

    % Store
    pos_hist(step,:) = r;
    v_hist(step)   = v;
    aT_hist(step)  = aT;
    aN_hist(step)  = aN;
    g_hist(step)   = gforce;
    t_hist(step)   = t;
    KE_hist(step)  = .5 * m * v^2;
    PE_hist(step)  = m * g * pos_hist(step, 3);

    % Advance time
    t = t + dt; step = step + 1;
end

% Trim
pos_hist = pos_hist(1:step-1,:);
v_hist   = v_hist(1:step-1);
aT_hist  = aT_hist(1:step-1);
aN_hist  = aN_hist(1:step-1);
g_hist   = g_hist(1:step-1);
t_hist   = t_hist(1:step-1);
KE_hist  = KE_hist(1:step-1);
PE_hist  = PE_hist(1:step-1);

%% === Animation ===
curve = Bezier(linspace(0,1,400),CP);

figure('Name','Particle Animation');
plot3(curve(:,1),curve(:,2),curve(:,3),'b-','LineWidth',1.5); hold on;
plot3(CP(:,1),CP(:,2),CP(:,3),'ro--');
hPart = plot3(pos_hist(1,1),pos_hist(1,2),pos_hist(1,3),'ko','MarkerSize',8,'MarkerFaceColor','k');
xlabel('x'); ylabel('y'); zlabel('z'); grid on; axis equal;
title('Particle on Bézier Curve');

for k=1:50:length(pos_hist)
    set(hPart,'XData',pos_hist(k,1),'YData',pos_hist(k,2),'ZData',pos_hist(k,3));
    drawnow;
end

%% === Plots of dynamics ===
figure('Name','G-Forces & Speed');

% Speed
subplot(4,1,1);
plot(t_hist, v_hist, 'k', 'LineWidth', 1.5); 
grid on;
ylabel('Speed [m/s]');
title('Speed');

% Accelerations
subplot(4,1,2);
plot(t_hist, aT_hist/g, 'r', 'LineWidth', 1.5); hold on;
plot(t_hist, aN_hist/g, 'b', 'LineWidth', 1.5);
ylabel('Acceleration [g]');
legend('Tangential','Normal','Location','best');
grid on;
title('Accelerations');

% Force
plot(t_hist, m * aT_hist/g, 'r', 'LineWidth', 1.5); hold on;
plot(t_hist,  m * aN_hist/g, 'b', 'LineWidth', 1.5);

% Net g-force
subplot(4,1,3);
plot(t_hist, g_hist, 'm', 'LineWidth', 1.5); hold on;
grid on;
ylabel('Total g');
xlabel('Time [s]');
title('Net g-force experienced');

% Energies
subplot(4,1,4);
plot(t_hist, KE_hist, 'r', 'LineWidth', 1.5); hold on;
plot(t_hist, PE_hist, 'b', 'LineWidth', 1.5);
E_tot = KE_hist + PE_hist;
plot(t_hist, E_tot, 'g', 'LineWidth', 1.5); % total energy
ylabel('Energy [J]');
legend('Kinetic','Potential','Total','Location','best');
grid on;
xlabel('Time [s]');
title('Energies');

%% --- Local functions: Bezier & derivative --- %%
function pts = Bezier(t, control_points)
    % t may be scalar or column vector. Returns length(t)-by-D matrix
    t = t(:);
    n = size(control_points,1) - 1;
    if n < 0
        pts = zeros(length(t), size(control_points,2));
        return;
    end
    binoms = arrayfun(@(k) nchoosek(n,k), 0:n);    % 1 x (n+1)
    % Build T^i and (1-T)^{n-i}
    Ti = bsxfun(@power, t, 0:n);                  % length(t) x (n+1)
    OneMinus = bsxfun(@power, 1-t, n:-1:0);       % length(t) x (n+1)
    B = bsxfun(@times, Ti .* OneMinus, binoms);   % length(t) x (n+1)
    pts = B * control_points;                     % length(t) x D
end

function d = BezierDerivative(t, control_points)
    % derivative dr/du of Bézier at parameter t (scalar t or column vector)
    t = t(:);
    n = size(control_points,1) - 1;
    if n <= 0
        d = zeros(length(t), size(control_points,2));
        return;
    end
    % derivative control points: n*(P_{i+1} - P_i), i=0..n-1
    dCP = n * (control_points(2:end,:) - control_points(1:end-1,:)); % n x D
    k = n - 1;
    binoms = arrayfun(@(j) nchoosek(k,j), 0:k);
    Ti = bsxfun(@power, t, 0:k);
    OneMinus = bsxfun(@power, 1-t, k:-1:0);
    B = bsxfun(@times, Ti .* OneMinus, binoms);   % length(t) x (k+1)
    d = B * dCP;                                   % length(t) x D
    % If input t was scalar, output as 1xD; if vector -> length(t) x D
end

function acc = BezierSecondDerivative(t, control_points)
    % BezierSecondDerivative
    % Computes second derivative (acceleration vector) of a Bézier curve
    % at parameter values t.
    %
    % INPUTS:
    %   t               - vector of parameter values in [0,1]
    %   control_points  - NxD matrix of control points (N points, D dims)
    %
    % OUTPUT:
    %   acc             - length(t)-by-D matrix of second derivative values

    n = size(control_points,1) - 1;   % degree
    D = size(control_points,2);       % dimension
    
    if n < 2
        error('Need at least 3 control points for a second derivative.');
    end

    % Build "second derivative control points"
    Q = zeros(n-1, D);
    for i = 0:n-2
        Q(i+1,:) = (n * (n-1)) * (control_points(i+3,:) ...
                        - 2*control_points(i+2,:) + control_points(i+1,:));
    end

    % Now Q are the control points for a (n-2)-degree Bézier curve
    acc = Bezier(t, Q); 
end